/* autogenerated by Processing revision 1272 on 2021-10-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.serial.*;
import java.lang.*;
import java.util.*;
import java.io.*;
import java.util.Properties;
import java.util.Date;
import javax.activation.*;
import java.io.FileWriter;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class InPulse_Processing_200 extends PApplet {

/*

      InPulse 2021
      Modified for the inPulse v2 hardware

      Integrated the changes in InPulse_Prompt_Only_04
      
      CHANGE THE SYNC AND THE HRV TO PERFORM THE OPPOSITE TASKS!
      
      ADD INSTRUCTION PROMPTS!
      
*/








//import javax.mail.*;
//import javax.mail.internet.*;
//import http.requests.*;
//import java.net.*;

//import java.io.BufferedWriter;

//FileWriter fw;
//BufferedWriter bw;

//PrintWriter writer;
//BufferedReader reader;

//PGraphics inPulse;
//SyphonServer server;


PFont font;
PFont score;

Serial port;

final int OUT_HOLD = 0;
final int IN_HOLD = 1;
final int IN = 2;
final int OUT = 3;

final int TOTAL_BREATHS = 25;
final int WIDTH = 1200;
final int HEIGHT = 800;

//color black = color(261,99,21);
IntList dots;

boolean exitSetup = false;

 public void setup(){
  /* size commented out by preprocessor */;   // production target
  //size(3900,2200,P2D); // super big
  //size(1200,800,P2D);    // working on smaller screen
  //inPulse = createGraphics(1200, 800, P2D);
  //server = new SyphonServer(this, "inPulse Syphon");
  colorMode(HSB,360,100,100);
  frameRate(60);
  font = loadFont("Arial-BoldMT-24.vlw");
  score = loadFont("Baskerville-48.vlw");
  textFont(font);
  textAlign(LEFT);
  rectMode(CENTER);
  ellipseMode(CENTER);
  
  serialConnect();
  
  // DATA LOGGING SETUP
  thisHour = lastHour = hour();
  initLogFile();
  // CONNECTION SETUP
  initConnection();
  // BREATH STUP
	initBreathPrompt();

  initSensors();
  
  thatTime = millis();
  exitSetup = true;
}



 public void draw(){
  //inPulse.beginDraw();
  //inPulse.colorMode(HSB,360,100,100);
  if(serialPortFound){
    background(261,99,21);
    drawConnection();
    drawBreathPrompt();
    //printScore();
    printDataToScreen();

  } else { // SCAN TO FIND THE SERIAL PORT
      autoScanPorts();
      if(refreshPorts){
        refreshPorts = false;
        background(261,99,21);
        listAvailablePorts();
      }

      for(int i=0; i<numPorts+1; i++){
        button[i].overRadio(mouseX,mouseY);
        button[i].displayRadio();
      }

    }
    //inPulse.endDraw();
    //image(inPulse,0,0);
    //server.sendImage(inPulse);
}


// BREATH PROMPT STUFF
// color of biggest ellipse
final float breathInHue = 207.0f;
final float breathInSat = 99.0f;
final float breathInBri = 99.0f;
// color of smallest ellipse
final float breathOutHue = 240.0f;
final float breathOutSat = 40.0f; 
final float breathOutBri = 93.0f; 
// color of fading ellipse
float thisBreathHue;
float thisBreathSat;
float thisBreathBri;
final int IN_HOLD_DURATION = 100;
final int OUT_HOLD_DURATION = 50;
final float maxBreathAlpha = 230;
float breathAlpha = maxBreathAlpha;
int holdCount;
int holdDuration;
float a = 0;
int breathing = OUT;
int breathCenterX;
int breathCenterY;
float lastBreathX;
float breathXmax = 3400.0f;
float breathYmax = 1800.0f;
float breathXmin = 400.0f;  // 200?
float breathYmin = 200.0f;  // 150?
float breathX = breathXmin;
float breathY = breathYmin;
float breathXstep = (breathXmax-breathXmin)/180.0f;
float breathYstep = (breathYmax-breathYmin)/180.0f;
float breathCycle; // = 60.0 / 6.0; // 10.0;
float breatheIn = 0.9f; // 60.0 / 10.0;
float breatheOut = 0.5f; //60.0 / 5.0;
float angle;

long thatTime;
int thisTime;


int breathCounter = 0;


 public void drawBreathPrompt() {
  // float r = ((millis()/1000.0)/breathCycle)*360;
  angle = radians(a);
  float s = sin(angle);
  // lastBreathX = breathX;
  breathX = 200 + (sin(angle) * breathXmax/2) + breathXmax/2;
  breathY = 150 + (sin(angle) * breathYmax/2) + breathYmax/2;

  thisBreathHue = map(breathX, breathXmin, breathXmax, breathOutHue, breathInHue);
  thisBreathSat = map(breathX, breathXmin, breathXmax, breathOutSat, breathInSat);
  thisBreathBri = map(breathX, breathXmin, breathXmax, breathOutBri, breathInBri);
  noStroke();
  fill(thisBreathHue, thisBreathSat, thisBreathBri, breathAlpha);
  //println("red "+thisBreathRed+" green "+thisBreathGreen+" blue "+thisBreathBlue);
  ellipse(breathCenterX, breathCenterY, breathX, breathY);

  if (breathX < lastBreathX && breathing == IN ) {
    breathing = IN_HOLD;
    holdCount = 0;
    holdDuration = IN_HOLD_DURATION;
    breathCycle = breatheOut;
    if (scoreState == BREATHE_IN) { 
      scoreState = HOLD_IN; 
      textFadeValue = -10;
    }
  }
  if (breathX > lastBreathX && breathing == OUT) {
    breathing = OUT_HOLD;
    holdCount = 0;
    holdDuration = OUT_HOLD_DURATION;
    breathCycle = breatheIn;
    if (scoreState == BREATHE_OUT) { 
      scoreState = HOLD_OUT; 
      textFadeValue = -25;
    }
  }
  lastBreathX = breathX;
  if (breathing == IN_HOLD || breathing == OUT_HOLD) {
    holdCount++;
    if (holdCount > holdDuration) {
      if (breathing == OUT_HOLD) {
        breathing = IN;
        thisTime = PApplet.parseInt(millis() - thatTime);
        thatTime = millis();
        //println(thisTime + "mS   " + nf(60000.0/float(thisTime),0,1) + " breaths/min   "
        //        +nf(breatheIn,0,1) +" in   " + holdDuration + " hold   " + nf(breatheOut,0,1) + " out");
        breathCounter++;
        //countBreaths();
        println("breathCounter "+breathCounter);
      }
      if (breathing == IN_HOLD) {
        breathing = OUT;
        if (scoreState == HOLD_IN) { 
          scoreState = BREATHE_OUT; 
          textFadeValue = -20;
        }
      }
    }
    return;
  }
  a += breathCycle;
  // println(r);
}


 public void initBreathPrompt() {
  breathCycle = breatheOut;
  breathCenterX = width/2;
  breathCenterY = height/2;
  // size the breath prompt to the screen
  breathXmax = width * 0.80f;
  breathYmax = height * 0.75f;
}


 public void countBreaths() {
  switch(breathCounter) {
  case TOTAL_BREATHS:
    breathCounter = -5;
    scoreState = CLASP;
    textFadeValue = 1;
    dotFadeCounter = 1;
    break;
  case -4:
    scoreState = BREATHE_IN;
    textFadeValue = -20;
    break;
  case -3:
    scoreState = BREATHE_IN;
    textFadeValue = -5;
    break;
  case -2:
    scoreState = SPHERES;
    textFadeValue = -5;
    break;
  case -1:
    scoreState = COLORS;
    textFadeValue = -20;
    break;
  case 0:
    scoreState = END_SCORE;
    textFadeValue = -2;
    dotFadeCounter = 1;
    break;
  case 1:
    scoreState = NO_PROGRESS;
    break;
  default:
    break;
  }
}

/*

     
*/


// CONNECTION STUFF
final int MIN_SYNC = 600;  // actual SYNC values
final int MAX_SYNC = 1;
final int MIN_HRV = 2;   // actual IBI values
final int MAX_HRV = 800; 
float maxHRVweight; // = 100;
float minHRVweight; // = 45;
int frameCounter = 1;
// low HRV color
final float syncLowHue = 407; //360+47;
final float syncLowSat = 94; 
final float syncLowBri = 81;
// high HRV color
final float syncHighHue = 214;
final float syncHighSat = 80;
final float syncHighBri = 73;
// drawn HRV color
float syncHue;
float syncSat;
float syncBri;
float[][] fadeDistance;
float maxDistance;
float targetHRVweight; // = minHRVweight;
float currentHRVweight; // = minHRVweight;
float HRVweight;
int[] runningSync = new int[5];  // average sync to avoid jittery
int[] runningHRV = new int[5];
int currentSync = MIN_SYNC;
int targetSync = MIN_SYNC;
int currentHRV = MIN_HRV;
int targetHRV = MIN_HRV;
boolean connecting = true;
int pointCount;
int syncGrowthFactor = 2;
int HRVgrowthFacor = 1;
float[] pointWeight;
int dotFadeCounter = 0;

int dotSpacer;

int hrvTotal;

int livePlayers;
int [] player = new int[2];

 public void drawConnection(){
  if(frameCounter == pointCount){
    frameCounter = 0;
    dots.shuffle();
    
  }
  
  // adjust for no players or one player
  if(livePlayers < 2){ targetSync = MIN_SYNC; }
    if(currentSync < targetSync){
      currentSync += syncGrowthFactor;
    } else if(currentSync > targetSync){
      currentSync -= syncGrowthFactor;
    }
  currentSync = constrain(currentSync, MAX_SYNC, MIN_SYNC);
  //println("curentSync "+currentSync);
  syncHue = map(currentSync,MIN_SYNC,MAX_SYNC,syncLowHue,syncHighHue);
  syncSat = map(currentSync,MIN_SYNC,MAX_SYNC,syncLowSat,syncHighSat);
  syncBri = map(currentSync,MIN_SYNC,MAX_SYNC,syncLowBri,syncHighBri);
  if(syncHue > 359){ syncHue -= 359; }
  
  if(livePlayers > 0){
    targetHRV = HRV[0] + HRV[1];
    if(livePlayers == 1){ targetHRV*= 2; }
  } else {
    targetHRV = MIN_HRV;
  }
  if(currentHRV < targetHRV){
    currentHRV += HRVgrowthFacor;
  } else if(currentHRV > targetHRV){
    currentHRV -= HRVgrowthFacor;
  }
  currentHRV = constrain(currentHRV,MIN_HRV, MAX_HRV);
  HRVweight = map(currentHRV,MIN_HRV,MAX_HRV,minHRVweight,maxHRVweight);
  
  //println("targetHRV: "+targetHRV+" hrv: "+currentHRV+" weight: "+HRVweight);
    // 24 dots by 16 dots
    // 1920 x 1080 = dotSpacer 
   int _x;
   int pointCounter = 0;
   int yCounter = 0;
   //println("pointCount "+pointCount);
   for (int y = 0; y < height-dotSpacer/2; y+=dotSpacer) { //-dotSpacer/2
     yCounter++;
      for (int x = 0; x < width-dotSpacer; x+=dotSpacer) {
        if(breathCounter < 0){
          float fadeOut = fadeDistance[x][y] - dotFadeCounter;
          fadeOut = constrain(fadeOut,0,fadeDistance[x][y]);
          stroke(syncHue, syncSat, syncBri, fadeOut);
        } else if(breathCounter == 0){
          float fadeIn = dotFadeCounter;
          fadeIn = constrain(fadeIn,0,fadeDistance[x][y]);
          stroke(syncHue, syncSat, syncBri, fadeIn);
        } else {
          stroke(syncHue, syncSat, syncBri, fadeDistance[x][y]);
        }
				if(yCounter % 2 == 0){
          _x = x + dotSpacer/2;  // this ofsets the rows
        } else {
          _x = x;
        }
        //println(pointCounter);
        //println(frameCounter);
        if(frameCounter == dots.get(pointCounter)){
            pointWeight[pointCounter] = HRVweight;
            //println("dot "+pointCounter);
        }
        strokeWeight(pointWeight[pointCounter]);
        point(_x + dotSpacer/2, y + dotSpacer/2);
        pointCounter++;
      }
    }
    frameCounter++;
    dotFadeCounter++;
}

 public void initConnection(){
  maxDistance = dist(width/2, height/2, width, height);
  fadeDistance = new float[width][height];
  for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
      float distance = dist(width/2, height/2, x, y);
      fadeDistance[x][y] = distance/maxDistance * 255; // this sets an alpha fade?
    }
  }
  
  dotSpacer = height/16;
  minHRVweight = dotSpacer * 0.85f;
  maxHRVweight = dotSpacer * 2.0f;
  targetHRVweight = minHRVweight;
  currentHRVweight = minHRVweight;
  pointCount = PApplet.parseInt((width/dotSpacer)*(height/dotSpacer));
  println("pointCount " + pointCount);
  dots = new IntList();
  pointWeight = new float[pointCount];
  for(int i=0; i<pointCount; i++){
    pointWeight[i] = HRVweight;
    dots.append(i);  
  }
  for(int i=0; i<runningSync.length; i++){
    runningSync[i] = MIN_SYNC;
  }
  for(int i=0; i<runningHRV.length; i++){
    runningHRV[i] = MIN_HRV;
  }
  //lastSync = currentSync;
  dots.shuffle();
  //println("curentSync "+currentSync);
}

 public int getTargetSync(int s){
  int runningTotal = 0;
  for(int i=0; i<runningSync.length-1; i++){
    runningSync[i] = runningSync[i+1];
    runningTotal += runningSync[i];
  }
  runningSync[runningSync.length-1] = s;
  runningTotal += s;
  return runningTotal/runningSync.length;
}

 public int getMeanHRV(int h){
  int runningTotal = 0;
  for(int i=0; i<runningHRV.length-1; i++){
    runningHRV[i] = runningHRV[i+1];
    runningTotal += runningHRV[i];
  }
  runningHRV[runningHRV.length-1] = h;
  runningTotal += h;
  return runningTotal/runningHRV.length;
}

 public void countPlayers(int p, int g){
  player[p] = g;
  livePlayers = player[0] + player[1];
  println("livePlayers: "+livePlayers);
  switch(livePlayers){
    case 0:
      targetHRV = MIN_HRV;
      //add sync reset here too?
      //reset running averages
      break;
    default:
      break;
  }
}



boolean logFileExists = false;
String logFilePath = "/Users/joelmurphy/Desktop";
String logFileName = "";
boolean stamp = true;
int thisHour;
int lastHour;


 public void logWriteSample(){
  String sample = livePlayers +","+ IBI[0] +","+ HRV[0] +","+ meanHRV[0] +","+ IBI[1]
                       +","+ HRV[1] +","+ meanHRV[1] +","+ SYNC +","+ targetSync;
  logWrite(sample);
}

 public void logWrite(String s){
  //println(s);
  thisHour = hour();
  if(thisHour != lastHour){
    lastHour = thisHour;
    //if(thisHour == 23){
    //  emailLogs();
    //}
    if(thisHour == 0){
      String today = year()+"_"+month()+"_"+day();
      logFileName = "inPulse_"+today+".csv";
    }
  }
  
  // println(sketchPath());
  try {
    logFilePath = "/Users/joelmurphy/Desktop/logs/" + logFileName;
    FileWriter output = new FileWriter(logFilePath, true);
    if(stamp){ output.write(timeStamp()+","); }
    output.write(s +"\n");
    output.flush();
    output.close();
  }

  catch(IOException e) {
    println("Event Log Write Failure");
    e.printStackTrace();
  }

  }

 public void initLogFile(){
  String today = year()+"_"+month()+"_"+day();
  logFileName = "inPulse_"+today+".csv";
  logWrite("Log Opened In Setup");
  stamp = false;
  logWrite("Time Stamp,Live Players,IBI[0],HRV[0],meanHRV[0],IBI[1],HRV[1],meanHRV[1],SYNC,targetSync");
  stamp = true;
}

 public String timeStamp(){
  String s = hour()+":"+minute()+":"+second();
  return s;
}



 public void keyPressed(){

 switch(key){
   case 's':    // pressing 's' or 'S' will take a jpg of the processing window
   case 'S':
     saveFrame("inPulse-####.jpg");      // take a shot of that!
     break;
   case 'm':
     //emailLogs();
     println("email logs not enabled");
     break;
   case 'l':
     println("Request to write sample to file");
     logWriteSample();
     break;
  // clear the screen when you press 'R' or 'r'
   //case 'r':
   //case 'R':
   //  resetVariables(0);
   //  resetVariables(1);
   //  break;
   //case 'W':
   //case 'w':
   //  //showWave = !showWave;
   //  break;
   //case '1':
   //  breatheIn += 0.1;
   //  breatheIn = constrain(breatheIn, 0.1, 1.0);
   //  println("breatheIn: " + nf(breatheIn,0,1));
   //  break;
   //case '2':
   //  breatheIn -= 0.1;
   //  breatheIn = constrain(breatheIn, 0.1, 1.0);
   //  println("breatheIn: " + nf(breatheIn,0,1));
   //  break;
   //case '3':
   //  //breathCycle = 60 / 5.0;
   //  break;
   //case '4':
   //  //breathCycle = 60 / 5.5;
   //  break;
   //case '5':
   //  holdDuration += 5;
   //  holdDuration = constrain(holdDuration, 5, 100);
   //  println("hold: " + holdDuration);
   //  break;
   //case '6':
   //  holdDuration -= 5;
   //  holdDuration = constrain(holdDuration, 5, 100);
   //  println("hold: " + holdDuration);
   //  break;
   //case '7':
   //  //breathCycle = 60 / 7.0;
   //  break;
   //case '8':
   //  //breathCycle = 60 / 7.5;
   //  break;
   //case '9':
   //  breatheOut += 0.1;
   //  breatheOut = constrain(breatheOut, 0.1, 1.0);
   //  println("breatheOut: " + nf(breatheOut,0,1));
   //  break;
   //case '0':
   //  breatheOut -= 0.1;
   //  breatheOut = constrain(breatheOut, 0.1, 1.0);
   //  println("breatheOut: " + nf(breatheOut,0,1));
   //  break;
   default:
     break;
 }
}



 public void mousePressed(){
  if(!serialPortFound){
    for(int i=0; i<=numPorts; i++){
      if(button[i].pressRadio(mouseX,mouseY)){
        if(i == numPorts){
          if(Serial.list().length > numPorts){
            println("New Ports Opened!");
            int diff = Serial.list().length - numPorts;  // was serialPorts.length
            serialPorts = expand(serialPorts,diff);
            //button = (Radio[]) expand(button,diff);
            numPorts = Serial.list().length;
          }else if(Serial.list().length < numPorts){
            println("Some Ports Closed!");
            numPorts = Serial.list().length;
          }else if(Serial.list().length == numPorts){
            return;
          }
          refreshPorts = true;
          return;
        }else

        try{
					// MAKE SURE THAT THE BAUD RATES AGREE!! LOST PACKETS ARE SAD!!
          port = new Serial(this, Serial.list()[i], 250000);
          delay(1000);
          println(port.read());
          port.clear();            // flush buffer
          port.bufferUntil('\n');  // set buffer full flag on receipt of carriage return
          serialPortFound = true;
        }
        catch(Exception e){
          println("Couldn't open port " + Serial.list()[i]);
          fill(255,0,0);
          textFont(font,16);
          text("Couldn't open port " + Serial.list()[i],165,90);
          textFont(font);
        }
      }
    }
  }
}

 public void mouseReleased(){
}


final int NO_PROGRESS = 0;
final int CLASP = 1;
final int BREATHE_IN = 2;
final int HOLD_IN  = 3;
final int BREATHE_OUT = 4;
final int HOLD_OUT = 5;
final int SPHERES = 6;
final int COLORS = 7;
final int END_SCORE = 8;
final int SCORE_BREATHS = 2;

int scoreState;
String scoreText1 = "";
String scoreText2 = "";
String scoreText3 = "";
float scoreTextY = 375;
float scoreTextLineSpace = 25;
float textFade;
float textFadeValue;
int scoreBreathCount = 0;


 public void printScore(){
  
  switch(scoreState){
    case CLASP:
      scoreText1 = "";
      scoreText2 = "GRIP THE SENSORS GENTLY";
      scoreText3 = "IN YOUR PALMS";
      break;
    case BREATHE_IN:
      if(textFade == 0){
        textFadeValue = 20;
        scoreText1 = "";
        scoreText2 = "BREATHE IN";
        scoreText3 = "";
      }
      break;
    case HOLD_IN:
      if(textFade == 0){
        textFadeValue = 20;
        scoreText1 = "";
        scoreText2 = "HOLD YOUR BREATH";
        scoreText3 = "";
      }
      break;
    case BREATHE_OUT:
      if(textFade == 0){
        textFadeValue = 20;
        scoreText1 = "";
        scoreText2 = "BREATHE OUT";
        scoreText3 = "";
      }
      break;
    case HOLD_OUT:
      if(textFade == 0){
        textFadeValue = 20;
        scoreText1 = "";
        scoreText2 = "HOLD YOUR BREATH";
        scoreText3 = "";
      }
      break;
    case SPHERES:
      if(textFade == 0){
        textFadeValue = 20;
        scoreText1 = "";
        scoreText2 = "THE SPHERES EXPAND";
        scoreText3 = "AS YOU BECOME CALMER";
      }
      break;
    case COLORS:
      if(textFade == 0){
        textFadeValue = 20;
        scoreText1 = "IF YOU ARE WITH SOMEONE ELSE";
        scoreText2 = "THE COLOR BECOMES VIOLET AS";
        scoreText3 = "YOUR HEART BEATS SYNC";
      }
      break;
    case END_SCORE:
      break;
    case NO_PROGRESS:
      scoreText1 = "";
      scoreText2 = "";
      scoreText3 = "";
      break;
    default:
      break;
  }
  if(scoreState > NO_PROGRESS){
    textFont(score,24);
    textAlign(CENTER);
    textFade += textFadeValue;
    textFade = constrain(textFade,0,255);
    fill(255,textFade);
    pushMatrix();
    translate(width/2, height/2); // Translate to the center
    rotate(radians(90));          // Rotate by radians(degree)
    text(scoreText1, 0, scoreTextY-scoreTextLineSpace); 
    text(scoreText2, 0, scoreTextY); 
    text(scoreText3, 0, scoreTextY+scoreTextLineSpace); 
    rotate(radians(180));
    text(scoreText1, 0, scoreTextY-scoreTextLineSpace); 
    text(scoreText2, 0, scoreTextY); 
    text(scoreText3, 0, scoreTextY+scoreTextLineSpace); 
    popMatrix();
    textFont(font);
    textAlign(LEFT);
  }
  
}



int numSensors = 2;
int[] Sensor = new int[2];      // HOLDS PULSE SENSOR DATA FROM ARDUINO
int[] IBI = new int[2];         // HOLDS TIME BETWEN HEARTBEATS FROM ARDUINO
int[] BPM = new int[2];         // HOLDS HEART RATE VALUE FROM ARDUINO
int[] HRV = new int[2];
int[] meanHRV = new int[2];
int[][] RawPPG;      // HOLDS HEARTBEAT WAVEFORM DATA BEFORE SCALING
int[][] ScaledPPG;   // USED TO POSITION SCALED HEARTBEAT WAVEFORM
int[][] ScaledIBI;      // USED TO POSITION BPM DATA WAVEFORM
float offset;    // USED WHEN SCALING PULSE WAVEFORM TO PULSE WINDOW
int eggshell = color(42, 2, 99);
int SYNC;

int PulseWindowWidth; // = 490;
int PulseWindowHeight; // = 512;
int PulseWindowX;
int[] PulseWindowY;
int BPMWindowWidth; // = 180;
int BPMWindowHeight; // = 340;
int BPMWindowX;
int[] BPMWindowY;

// HRV TOOLS
int[] lastIBI = {0,0};
boolean[] goingUp = {false, false};
String[] direction = {"",""};
int[] P = new int[2];
int[] T= new int[2];
int[] amp = new int[2];
int[] mean = new int[2];
float[] freq= new float[2];
float[] runningTotal = {0.0f, 0.0f}; // 1.0;
int[] hrv = {0,0};
boolean[] beat = new boolean[2];    // set when a heart beat is detected, then cleared when the BPM graph is advanced

float[] sensorDataX = new float[2];
float sensorDataY = 30;

boolean showWave = false;

/*
    Recieves the sensor number [0,1]
    Returns the most recent amp for that sensor
*/
 public int getHRV(int x){
    if (IBI[x] < T[x]){                        // T is the trough
      T[x] = IBI[x];                         // keep track of lowest point in pulse wave
    }
    if (IBI[x] > P[x]){                        // P is the trough
      P[x] = IBI[x];                         // keep track of highest point in pulse wave
    }
    runningTotal[x] += IBI[x];               // how long since IBI wave changed direction?

    if (IBI[x] < lastIBI[x] && goingUp[x] == true){  // check for IBI wave peak
      goingUp[x] = false;                 // now changing direction from up to down
      direction[x] = "down";              // used in verbose feedback
      freq[x] = (runningTotal[x]/1000) *2;   // scale milliseconds to seconds account for 1/2 wave data
      freq[x] = 1/freq[x];                   // convert time IBI trending up to Hz
      runningTotal[x] = 0;                // reset this for next time
      amp[x] = P[x]-T[x];                       // measure the size of the IBI 1/2 wave that just happend
      mean[x] = P[x]-amp[x]/2;                  // the average is useful for VLF derivation.......
      T[x] = lastIBI[x];                     // set the last IBI as the most recent trough cause we're going down
      
    }

    if (IBI[x] > lastIBI[x] && goingUp[x] == false){  // check for IBI wave trough
      goingUp[x] = true;                  // now changing direction from down to up
      direction[x] = "up";                // used in verbose feedback
      freq[x] = (runningTotal[x]/1000) * 2;  // scale milliseconds to seconds, account for 1/2 wave data
      freq[x] = 1/freq[x];                   // convert time IBI trending up to Hz
      runningTotal[x] = 0;                // reset this for next time
      amp[x] = P[x]-T[x];                       // measure the size of the IBI 1/2 wave that just happend
      mean[x] = P[x]-amp[x]/2;                  // the average is useful for VLF derivation.......
      P[x] = lastIBI[x];                     // set the last IBI as the most recent peak cause we're going up
      
    }
    lastIBI[x] = IBI[x];                     // keep track to measure the trend

    return amp[x];
}


// void drawDataWindows(){
//   noStroke();
//   // DRAW OUT THE PULSE WINDOW AND BPM WINDOW RECTANGLES
//   fill(eggshell);  // color for the window background
//   for(int i=0; i<numSensors; i++){
//     rect(PulseWindowX, PulseWindowY[i], PulseWindowWidth, PulseWindowHeight);
//     rect(BPMWindowX, BPMWindowY[i], BPMWindowWidth, BPMWindowHeight);
//   }
// }

 public void drawPulseWaveform(){
  // DRAW THE PULSE WAVEFORM
  // prepare pulse data points
  for (int i=0; i<numSensors; i++) {
    RawPPG[i][PulseWindowWidth-1] = (1023 - Sensor[i]);   // place the new raw datapoint at the end of the array

    for (int j = 0; j < PulseWindowWidth-1; j++) {      // move the pulse waveform by
      RawPPG[i][j] = RawPPG[i][j+1];                         // shifting all raw datapoints one pixel left
      float dummy = RawPPG[i][j] * 0.625f/numSensors;       // adjust the raw data to the selected scale
      offset = PApplet.parseFloat(PulseWindowY[i]);                // calculate the offset needed at this window
      ScaledPPG[i][j] = PApplet.parseInt(dummy) + PApplet.parseInt(offset);   // transfer the raw data array to the scaled array
    }
    stroke(0, 99, 99);                               // red is a good color for the pulse waveform
    noFill();
    beginShape();                                  // using beginShape() renders fast
    for (int x = 1; x < PulseWindowWidth-1; x++) {
      vertex(x+10, ScaledPPG[i][x]);                    //draw a line connecting the data points
    }
    endShape();
  }

}

 public void drawIBIwaveform(){
// DRAW THE BPM WAVE FORM
// first, shift the BPM waveform over to fit then next data point only when a beat is found
  for(int i=0; i<numSensors; i++){  // ONLY ADVANCE THE BPM WAVEFORM WHEN THERE IS A BEAT
    if(beat[i] == true){   // move the heart rate line over one pixel every time the heart beats
      beat[i] = false;      // clear beat flag (beat flag waset in serialEvent tab)
      HRV[i] = getHRV(i);
      for(int j=0; j<BPMWindowWidth-1; j++){
        ScaledIBI[i][j] = ScaledIBI[i][j+1];                  // shift the bpm Y coordinates over one pixel to the left
      }
      // then limit and scale the BPM value
      IBI[i] = constrain(IBI[i], 500, 1300);                     // limit the IBI values
      float dummy = map(IBI[i], 500, 1300, BPMWindowY[i]+BPMWindowHeight, BPMWindowY[i]);   // map it to the heart rate window Y
      ScaledIBI[i][BPMWindowWidth-1] = PApplet.parseInt(dummy);       // set the rightmost pixel to the new data point value
    }
  }
  if(!showWave){ return; }
  // GRAPH THE HEART RATE WAVEFORM
  stroke(0, 100, 100);                          // color of heart rate graph
  strokeWeight(2);                          // thicker line is easier to read
  noFill();

  for(int i=0; i<numSensors; i++){
    beginShape();
    for (int j=0; j < BPMWindowWidth; j++) {    // variable 'j' will take the place of pixel x position
     vertex(j+BPMWindowX, ScaledIBI[i][j]);                 // display history of heart rate datapoints
    }
    endShape();
  }
}





//void resetDataTraces(){
//  for (int i=0; i<numSensors; i++) {
//    BPM[i] = 0;
//    for(int j=0; j<BPMWindowWidth; j++){
//      ScaledIBI[i][j] = BPMWindowY[i] + BPMWindowHeight;
//    }
//  }
//  for (int i=0; i<numSensors; i++) {
//    Sensor[i] = 512;
//    for (int j=0; j<PulseWindowWidth; j++) {
//      RawPPG[i][j] = 1024 - Sensor[i]; // initialize the pulse window data line to V/2
//    }
//  }
//}

 public void resetVariables(int s){

    IBI[s] = 0;
    HRV[s] = 0;
    //for(int j=0; j<BPMWindowWidth; j++){
    //  ScaledIBI[s][j] = BPMWindowY[s] + BPMWindowHeight;
    //}

    // Sensor[s] = 512;
    // for (int j=0; j<PulseWindowWidth; j++) {
    //   RawPPG[s][j] = 1024 - Sensor[s]; // initialize the pulse window data line to V/2
    // }

}

 public void printDataToScreen(){ // PRINT THE DATA AND VARIABLE VALUES
    fill(42,2,99);                                       // get ready to print text
    // text("ImPulse Visualizer", 245, 30);     // tell them what you are
    for (int i=0; i<numSensors; i++) {
      // text("freq " + nf(freq[i],0,2), 800, BPMWindowY[i] + 260);
      text("HRV " + HRV[i], sensorDataX[i], sensorDataY);
      // text(BPM[i] + " BPM", sensorDataX[i], BPMWindowY[i] +185);// 215          // print the Beats Per Minute
      text("IBI " + IBI[i] + "mS", sensorDataX[i], sensorDataY + 30);// 245   // print the time between heartbeats in mS
    }
    text("SYNC " + SYNC + "mS", sensorDataX[0], height-30);
}

 public void initSensors(){
  //PulseWindowWidth = 490;
  //PulseWindowHeight = 640/numSensors;
  //PulseWindowX = 10;
  //PulseWindowY = new int [numSensors];
  //for(int i=0; i<numSensors; i++){
  //  PulseWindowY[i] = 43 + (PulseWindowHeight * i);
  //  if(i > 0) PulseWindowY[i]+=spacer*i;
  //}
  //BPMWindowWidth = 180;
  //BPMWindowHeight = PulseWindowHeight;
  //BPMWindowX = PulseWindowX + PulseWindowWidth + 10;
  //BPMWindowY = new int [numSensors];
  //for(int i=0; i<numSensors; i++){
  //  BPMWindowY[i] = 43 + (BPMWindowHeight * i);
  //  if(i > 0) BPMWindowY[i]+=spacer*i;
  //}
  beat = new boolean[numSensors];
  // Data Variables Setup
  Sensor = new int[numSensors];      // HOLDS PULSE SENSOR DATA FROM ARDUINO
  IBI = new int[numSensors];         // HOLDS TIME BETWEN HEARTBEATS FROM ARDUINO
  BPM = new int[numSensors];         // HOLDS HEART RATE VALUE FROM ARDUINO
  HRV = new int[numSensors];         // HOLDS THE LATEST IBI WAVE AMPLITUDE
  //RawPPG = new int[numSensors][PulseWindowWidth];          // initialize raw pulse waveform array
  //ScaledPPG = new int[numSensors][PulseWindowWidth];       // initialize scaled pulse waveform array
  //ScaledIBI = new int [numSensors][BPMWindowWidth];           // initialize BPM waveform array
  sensorDataX[0] = 50;
  sensorDataX[1] = width - 150;
  // set the visualizer lines to 0
  //resetDataTraces();
}

String serialPort;
String[] serialPorts = new String[Serial.list().length];
boolean serialPortFound = false;
Radio[] button = new Radio[Serial.list().length*2];
int numPorts = 0;
boolean refreshPorts = false;



 public void serialEvent(Serial port){
  boolean logData = false;
try{
   String inData = port.readStringUntil('\n');
   inData = trim(inData);                 // cut off white space (carriage return)

 for(int i=0; i<numSensors;i++){
   if (inData.charAt(0) == 'a'+i){           // leading 'a' for sensor data
     inData = inData.substring(1);           // cut off the leading 'a'
     Sensor[i] = PApplet.parseInt(inData);                // convert the string to usable int
   }
   if (inData.charAt(0) == 'A'+i){           // leading 'A' for BPM data
     inData = inData.substring(1);           // cut off the leading 'A'
     BPM[i] = PApplet.parseInt(inData);                   // convert the string to usable int
     logData = true;
   }
   if (inData.charAt(0) == 'M'+i){             // leading 'M' means IBI data
       inData = inData.substring(1);           // cut off the leading 'M'
       IBI[i] = PApplet.parseInt(inData);                   // convert the string to usable int
       beat[i] = true;                         // set beat flag to advance heart rate graph
       HRV[i] = getHRV(i);
       meanHRV[i] = getMeanHRV(HRV[i]);    // do we need meanHRV?
       logData = true;
     }
   }
   
   if (inData.charAt(0) == 'X'){             // leading 'X' means SYNC data
     inData = inData.substring(1);           // cut off the leading 'T'
     SYNC = PApplet.parseInt(inData);                      // convert the string to usable int
     targetSync = getTargetSync(SYNC);
     logData = true;
   }
   
   if (inData.charAt(0) == '*'){             // leading '*' means Lead Off
     inData = inData.substring(1);           // 
     resetVariables(PApplet.parseInt(inData));            // 
     countPlayers(PApplet.parseInt(inData),0);
     println("* "+PApplet.parseInt(inData));
     logData = true;
   }
   
   if (inData.charAt(0) == '$'){             // leading '$' means Lead On
     inData = inData.substring(1);
     countPlayers(PApplet.parseInt(inData),1);
     println("$ "+PApplet.parseInt(inData));
     logData = true;
   }
   
   if(logData){
     logWriteSample();
   }

} catch(Exception e) {
  print("Serial Error: ");
  println(e.toString());
}

}


 public void serialConnect(){
  println(Serial.list());    // print a list of available serial ports to the console
  // serialPorts = Serial.list();

  try{
    // make sure Arduino is talking serial at 250000 baud
    port = new Serial(this, Serial.list()[Serial.list().length-2], 250000);
    delay(500);
    println(port.read());
    port.clear();            // flush buffer
    port.bufferUntil('\n');  // set buffer full flag on receipt of carriage return
    serialPortFound = true;
    println("Connected to "+Serial.list()[Serial.list().length-2]);
  }
  catch(Exception e){
    println("Couldn't open port " + Serial.list()[Serial.list().length-2]);
    if(exitSetup){
      fill(255);
      textFont(font,16);
      text("Couldn't open port " + Serial.list()[Serial.list().length-2],60,70);
      textFont(font);
    }
  }

}


 public void listAvailablePorts(){
  println(Serial.list());    // print a list of available serial ports to the console
  serialPorts = Serial.list();
  fill(255);
  textFont(font,16);
  // set a counter to list the ports backwards
  int yPos = 0;

  for(int i=numPorts-1; i>=0; i--){
    button[i] = new Radio(35, 95+(yPos*20),12,color(180),color(80),color(255),i,button);
    text(serialPorts[i],50, 100+(yPos*20));
    yPos++;
  }
  int p = numPorts;
   //inPulse.fill(255);
  button[p] = new Radio(35, 95+(yPos*20),12,color(180),color(80),color(255),p,button);
    text("Refresh Serial Ports List",50, 100+(yPos*20));

  textFont(font);
}

 public void autoScanPorts(){
  if(Serial.list().length != numPorts){
    if(Serial.list().length > numPorts){
      println("New Ports Opened!");
      int diff = Serial.list().length - numPorts;	// was serialPorts.length
      serialPorts = expand(serialPorts,diff);
      numPorts = Serial.list().length;
    }else if(Serial.list().length < numPorts){
      println("Some Ports Closed!");
      numPorts = Serial.list().length;
    }
    refreshPorts = true;
    return;
}
}


class Radio {
  int _x,_y;
  int size, dotSize;
  int baseColor, overColor, pressedColor;
  boolean over, pressed;
  int me;
  Radio[] radios;

  Radio(int xp, int yp, int s, int b, int o, int p, int m, Radio[] r) {
    _x = xp;
    _y = yp;
    size = s;
    dotSize = size - size/3;
    baseColor = b;
    overColor = o;
    pressedColor = p;
    radios = r;
    me = m;
  }

   public boolean pressRadio(float mx, float my){
    if (dist(_x, _y, mx, my) < size/2){
      pressed = true;
      for(int i=0; i<numPorts+1; i++){
        if(i != me){ radios[i].pressed = false; }
      }
      return true;
    } else {
      return false;
    }
  }

   public boolean overRadio(float mx, float my){
    if (dist(_x, _y, mx, my) < size/2){
      over = true;
      for(int i=0; i<numPorts+1; i++){
        if(i != me){ radios[i].over = false; }
      }
      return true;
    } else {
      over = false;
      return false;
    }
  }

   public void displayRadio(){
    noStroke();
    fill(baseColor);
    ellipse(_x,_y,size,size);
    if(over){
      fill(overColor);
      ellipse(_x,_y,dotSize,dotSize);
    }
    if(pressed){
      fill(pressedColor);
      ellipse(_x,_y,dotSize,dotSize);
    }
  }
}


  public void settings() { fullScreen(P2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "InPulse_Processing_200" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
